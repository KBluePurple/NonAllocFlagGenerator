#nullable enable

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NonAllocFlags.Generator
{
    [Generator]
    public class FlagExtensionsIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var enumDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is EnumDeclarationSyntax,
                    transform: static (ctx, _) => GetEnumDeclarationForSourceGen(ctx)
                )
                .Where(static m => m is not null)
                .Collect();

            IncrementalValueProvider<(Compilation, ImmutableArray<EnumDeclarationSyntax>)> compilationAndEnums =
                context.CompilationProvider.Combine(enumDeclarations)!;

            context.RegisterSourceOutput(compilationAndEnums, Execute);
        }

        private static EnumDeclarationSyntax? GetEnumDeclarationForSourceGen(GeneratorSyntaxContext context)
        {
            var enumDeclaration = (EnumDeclarationSyntax)context.Node;

            return enumDeclaration.AttributeLists
                .SelectMany(al => al.Attributes).Any(a => a.Name.ToString() is "Flags" or "FlagsAttribute")
                ? enumDeclaration
                : null;
        }

        private static bool IsEnumInOpenGenericContext(INamedTypeSymbol enumSymbol)
        {
            var containingType = enumSymbol.ContainingType;
            while (containingType != null)
            {
                if (containingType.IsGenericType)
                {
                    foreach (var typeArgument in containingType.TypeArguments)
                    {
                        if (typeArgument is not ITypeParameterSymbol typeParamSymbolArg) continue;
                        if (containingType.TypeParameters.Contains(typeParamSymbolArg,
                                SymbolEqualityComparer.Default))
                        {
                            return true;
                        }
                    }
                }

                containingType = containingType.ContainingType;
            }

            return false;
        }

        private static void Execute(SourceProductionContext context,
            (Compilation compilation, ImmutableArray<EnumDeclarationSyntax> enums) source)
        {
            var (compilation, enums) = source;

            if (enums.IsDefaultOrEmpty)
            {
                return;
            }

            var extensionMethods = new[]
            {
                (Name: "HasFlagNonAlloc", Param: "flag", Impl: "return (value & flag) == flag;"),
                (Name: "HasAnyFlag", Param: "flags", Impl: "return (value & flags)!= 0;")
            };

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("#nullable enable");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Runtime.CompilerServices;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine(
                "");
            sourceBuilder.AppendLine("public static class FlagExtensionsGenerated");
            sourceBuilder.AppendLine("{");

            var processedCount = 0;

            foreach (var enumDeclaration in enums.Distinct())
            {
                context.CancellationToken.ThrowIfCancellationRequested();

                var model = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);
                if (!(model.GetDeclaredSymbol(enumDeclaration,
                        context.CancellationToken) is INamedTypeSymbol enumSymbol))
                    continue;

                if (!IsFlagsEnum(enumSymbol))
                    continue;

                if (IsEnumInOpenGenericContext(enumSymbol))
                {
                    continue;
                }

                var effectiveAccessibilityOfEnum = GetEffectiveAccessibility(enumSymbol);

                string extensionMethodModifier;

                switch (effectiveAccessibilityOfEnum)
                {
                    case Accessibility.Public:
                        extensionMethodModifier = "public";
                        break;
                    case Accessibility.Internal:
                    case Accessibility.ProtectedOrInternal:
                        extensionMethodModifier = "internal";
                        break;

                    case Accessibility.Private:
                    case Accessibility.Protected:
                    case Accessibility.ProtectedAndInternal:
                    case Accessibility.NotApplicable:
                    default:
                        continue;
                }

                var enumPath = enumSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                foreach (var method in extensionMethods)
                {
                    AddExtensionMethod(sourceBuilder, extensionMethodModifier, enumPath, method.Name, method.Param,
                        method.Impl);
                }

                processedCount++;
            }

            sourceBuilder.AppendLine("}");

            if (processedCount > 0)
            {
                context.AddSource($"{source.compilation.AssemblyName}.FlagExtensions.g.cs", sourceBuilder.ToString());
            }
        }

        private static bool IsFlagsEnum(INamedTypeSymbol enumSymbol)
        {
            return enumSymbol is { TypeKind: TypeKind.Enum } &&
                   enumSymbol.GetAttributes().Any(ad =>
                       ad.AttributeClass?.ContainingNamespace?.ToDisplayString() == "System" &&
                       ad.AttributeClass.Name == "FlagsAttribute");
        }

        private static Accessibility GetEffectiveAccessibility(ISymbol symbol)
        {
            var mostRestrictiveAccessibility = symbol.DeclaredAccessibility;
            var container = symbol.ContainingSymbol;

            while (container != null && container is not INamespaceSymbol)
            {
                if (container.DeclaredAccessibility < mostRestrictiveAccessibility)
                {
                    mostRestrictiveAccessibility = container.DeclaredAccessibility;
                }

                container = container.ContainingSymbol;
            }

            return mostRestrictiveAccessibility;
        }

        private static void AddExtensionMethod(
            StringBuilder builder,
            string accessModifier,
            string enumPath,
            string methodName,
            string paramName,
            string implementation)
        {
            builder.AppendLine();
            builder.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine(
                $"    {accessModifier} static bool {methodName}(this {enumPath} value, {enumPath} {paramName})");
            builder.AppendLine("    {");
            builder.AppendLine($"        {implementation}");
            builder.AppendLine("    }");
        }
    }
}