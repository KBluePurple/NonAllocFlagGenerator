using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NonAllocFlags.Generator
{
    [Generator]
    public class FlagExtensionsGenerator : ISourceGenerator
    {
        private class FlagEnumSyntaxReceiver : ISyntaxReceiver
        {
            public List<EnumDeclarationSyntax> CandidateEnums { get; } = new List<EnumDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is EnumDeclarationSyntax enumDeclaration)
                {
                    CandidateEnums.Add(enumDeclaration);
                }
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new FlagEnumSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var receiver = context.SyntaxReceiver as FlagEnumSyntaxReceiver;
            if (receiver == null)
                return;

            var extensionMethods = new Dictionary<string, string>
            {
                ["HasFlagNonAlloc"] = "return (value & flag) == flag;",
                ["HasAnyFlag"] = "return (value & flags) != 0;"
            };

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace FlagExtensions");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("    public static class FlagExtensionsGenerated");
            sourceBuilder.AppendLine("    {");

            var processedCount = 0;

            foreach (var enumDeclaration in receiver.CandidateEnums)
            {
                var model = context.Compilation.GetSemanticModel(enumDeclaration.SyntaxTree);

                if (!(model.GetDeclaredSymbol(enumDeclaration) is INamedTypeSymbol enumSymbol) ||
                    !IsFlagsEnum(enumSymbol) || !IsAccessible(enumSymbol))
                    continue;

                var enumPath = enumSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var accessModifier = GetAccessModifierString(enumSymbol);

                foreach (var method in extensionMethods)
                {
                    AddExtensionMethod(sourceBuilder, accessModifier, enumPath, method.Key, method.Value);
                }

                processedCount++;
            }

            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            if (processedCount > 0)
            {
                context.AddSource($"FlagExtensions.g.cs", sourceBuilder.ToString());
            }
        }

        private static bool IsFlagsEnum(INamedTypeSymbol enumSymbol)
        {
            return enumSymbol.TypeKind == TypeKind.Enum &&
                   enumSymbol.GetAttributes().Any(ad => ad.AttributeClass?.Name == "FlagsAttribute");
        }

        private static bool IsAccessible(INamedTypeSymbol enumSymbol)
        {
            var accessibility = GetAccessibility(enumSymbol);
            return accessibility == Accessibility.Public || accessibility == Accessibility.Internal;
        }

        private static string GetAccessModifierString(INamedTypeSymbol enumSymbol)
        {
            return GetAccessibility(enumSymbol) == Accessibility.Public ? "public" : "internal";
        }

        private static void AddExtensionMethod(
            StringBuilder builder,
            string accessModifier,
            string enumPath,
            string methodName,
            string implementation)
        {
            var paramName = methodName.StartsWith("HasAny") ? "flags" : "flag";

            builder.AppendLine(
                $"        {accessModifier} static bool {methodName}(this {enumPath} value, {enumPath} {paramName})");
            builder.AppendLine("        {");
            builder.AppendLine($"            {implementation}");
            builder.AppendLine("        }");
            builder.AppendLine();
        }

        private static Accessibility GetAccessibility(ISymbol symbol)
        {
            var current = symbol;
            var accessibility = current.DeclaredAccessibility;

            while (current.ContainingSymbol != null)
            {
                current = current.ContainingSymbol;

                if (current.DeclaredAccessibility == Accessibility.NotApplicable)
                    continue;

                accessibility = accessibility < current.DeclaredAccessibility
                    ? accessibility
                    : current.DeclaredAccessibility;
            }

            return accessibility;
        }
    }
}