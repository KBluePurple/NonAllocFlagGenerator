using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace NonAllocFlags.Generator
{
    [Generator]
    public class FlagExtensionsIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var enumDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => s is EnumDeclarationSyntax,
                    transform: static (ctx, _) => (EnumDeclarationSyntax)ctx.Node
                )
                .Where(enumDecl => enumDecl != null);

            IncrementalValueProvider<(Compilation, ImmutableArray<EnumDeclarationSyntax>)> compilationAndEnums =
                context.CompilationProvider.Combine(enumDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndEnums, Execute);
        }

        private static void Execute(SourceProductionContext context,
            (Compilation compilation, ImmutableArray<EnumDeclarationSyntax> enums) source)
        {
            var compilation = source.compilation;
            var enums = source.enums;

            var extensionMethods = new Dictionary<string, string>
            {
                ["HasFlagNonAlloc"] = "return (value & flag) == flag;",
                ["HasAnyFlag"] = "return (value & flags) != 0;"
            };

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Runtime.CompilerServices;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("public static class FlagExtensionsGenerated");
            sourceBuilder.AppendLine("{");

            var processedCount = 0;

            foreach (var enumDeclaration in enums)
            {
                var model = compilation.GetSemanticModel(enumDeclaration.SyntaxTree);

                if (!(model.GetDeclaredSymbol(enumDeclaration) is INamedTypeSymbol enumSymbol) ||
                    !IsFlagsEnum(enumSymbol) || !IsAccessible(enumSymbol))
                    continue;

                var enumPath = enumSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var accessModifier = GetAccessModifierString(enumSymbol);

                foreach (var method in extensionMethods)
                {
                    AddExtensionMethod(sourceBuilder, accessModifier, enumPath, method.Key, method.Value);
                }

                processedCount++;
            }

            sourceBuilder.AppendLine("}");

            if (processedCount > 0)
            {
                context.AddSource("FlagExtensions.g.cs", sourceBuilder.ToString());
            }
        }

        private static bool IsFlagsEnum(INamedTypeSymbol enumSymbol)
        {
            return enumSymbol.TypeKind == TypeKind.Enum &&
                   enumSymbol.GetAttributes().Any(ad => ad.AttributeClass?.Name == "FlagsAttribute");
        }

        private static bool IsAccessible(INamedTypeSymbol enumSymbol)
        {
            var accessibility = GetAccessibility(enumSymbol);
            return accessibility == Accessibility.Public || accessibility == Accessibility.Internal;
        }

        private static string GetAccessModifierString(INamedTypeSymbol enumSymbol)
        {
            return GetAccessibility(enumSymbol) == Accessibility.Public ? "public" : "internal";
        }

        private static void AddExtensionMethod(
            StringBuilder builder,
            string accessModifier,
            string enumPath,
            string methodName,
            string implementation)
        {
            var paramName = methodName.StartsWith("HasAny") ? "flags" : "flag";

            builder.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            builder.AppendLine(
                $"    {accessModifier} static bool {methodName}(this {enumPath} value, {enumPath} {paramName})");
            builder.AppendLine("    {");
            builder.AppendLine($"        {implementation}");
            builder.AppendLine("    }");
            builder.AppendLine();
        }

        private static Accessibility GetAccessibility(ISymbol symbol)
        {
            var current = symbol;
            var accessibility = current.DeclaredAccessibility;

            while (current.ContainingSymbol != null)
            {
                current = current.ContainingSymbol;

                if (current.DeclaredAccessibility == Accessibility.NotApplicable)
                    continue;

                accessibility = accessibility < current.DeclaredAccessibility
                    ? accessibility
                    : current.DeclaredAccessibility;
            }

            return accessibility;
        }
    }
}